import tkinter as tk
from tkinter import scrolledtext, messagebox
from math import prod


def euclides_estendido(a, b):
    """ Implementação do Teorema Chinês do Resto. """
    if a == 0:
        return b, 0, 1
    mdc, x1, y1 = euclides_estendido(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return mdc, x, y

def inverso_multiplicativo(a, n):
    """ Encontra o inverso multiplicativo de 'a' módulo 'n'. """
    mdc, x, y = euclides_estendido(a, n)
    if mdc != 1:
        raise ValueError(f"mdc({a}, {n}) != 1. Os módulos devem ser primos entre si.")
    return x % n


class AppTCR:
    def __init__(self, master):
        self.master = master
        master.title("Teorema Chinês do Resto (TCR) - Passo a Passo")
        master.geometry("700x600")

        self.a_list = []
        self.n_list = []
        self.k = 0
        self.N = None
        self.M = []
        self.y = []
        self.termo_index = 0
        self.x_solucao = 0
        self.passo_atual = 0  

        self.label_titulo = tk.Label(master, text="Resolvedor TCR", font=("Helvetica", 16, "bold"))
        self.label_titulo.pack(pady=10)

        input_frame = tk.Frame(master)
        input_frame.pack(pady=10)

        tk.Label(input_frame, text="Restos (a_i):", font=("Helvetica", 10)).grid(row=0, column=0, padx=5, sticky='w')
        self.entry_a = tk.Entry(input_frame, width=50); self.entry_a.insert(0, "2, 3, 2") 
        self.entry_a.grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(input_frame, text="Módulos (n_i):", font=("Helvetica", 10)).grid(row=1, column=0, padx=5, sticky='w')
        self.entry_n = tk.Entry(input_frame, width=50); self.entry_n.insert(0, "3, 5, 7")
        self.entry_n.grid(row=1, column=1, padx=5, pady=5)

        tk.Label(master, text="Separe os números por vírgula. Módulos devem ser coprimos.", fg="gray").pack()

    
        control_frame = tk.Frame(master)
        control_frame.pack(pady=15)
        
        self.setup_button = tk.Button(control_frame, text="1. Iniciar/Reiniciar", command=self.iniciar_solucao, 
                                      bg="#007bff", fg="white", font=("Helvetica", 12, "bold"))
        self.setup_button.grid(row=0, column=0, padx=10, ipady=5)

        self.next_button = tk.Button(control_frame, text="2. Próximo Passo >>", command=self.executar_proximo_passo, 
                                     bg="#28a745", fg="white", font=("Helvetica", 12, "bold"), state=tk.DISABLED)
        self.next_button.grid(row=0, column=1, padx=10, ipady=5)
        
        tk.Label(master, text="Resultados e Progresso:", font=("Helvetica", 12)).pack(pady=5)
        self.output_text = scrolledtext.ScrolledText(master, wrap=tk.WORD, width=80, height=18, font=("Courier", 10))
        self.output_text.pack(padx=10, pady=10)
        
    def log_passo(self, texto, estilo=None):
        """ Adiciona texto formatado ao widget. """
        self.output_text.insert(tk.END, texto + "\n", estilo)
        self.output_text.see(tk.END) 
    
    def log_passo_titulo(self, texto):
        self.output_text.tag_config('titulo', foreground='blue', font=('Courier', 10, 'bold'))
        self.log_passo("\n" + "="*50, 'titulo')
        self.log_passo("  " + texto, 'titulo')
        self.log_passo("="*50, 'titulo')

    def iniciar_solucao(self):
        """ Prepara o sistema e o estado inicial. """
        try:
            a_str = self.entry_a.get().replace(" ", "")
            n_str = self.entry_n.get().replace(" ", "")
            
            self.a_list = [int(x) for x in a_str.split(',') if x]
            self.n_list = [int(x) for x in n_str.split(',') if x]
            
            if len(self.a_list) != len(self.n_list) or not self.a_list:
                raise ValueError("Restos e módulos devem ser fornecidos em pares e não podem ser vazios.")
            
            self.k = len(self.a_list)
            self.M = []
            self.y = []
            self.N = None
            self.x_solucao = 0
            self.termo_index = 0
            self.passo_atual = 1 
            
            self.output_text.delete(1.0, tk.END)
            self.log_passo("--- INICIANDO NOVO CÁLCULO TCR ---", 'titulo')
            self.log_passo("Sistema de Congruências:", 'titulo')
            for a_i, n_i in zip(self.a_list, self.n_list):
                self.log_passo(f"  x ≡ {a_i} (mod {n_i})")

            self.next_button.config(state=tk.NORMAL)
            self.setup_button.config(text="1. Reiniciar")

        except ValueError as e:
            messagebox.showerror("Erro de Formato", str(e))
            self.next_button.config(state=tk.DISABLED)

    def executar_proximo_passo(self):
        """ Executa a próxima etapa do algoritmo TCR. """
        try:
            if self.passo_atual == 1:
                self._passo1_modulo_total()
            elif self.passo_atual == 2:
                self._passo2_3_fatores_inversos()
            elif self.passo_atual == 3:
                self._passo4_construcao_da_solucao()
            elif self.passo_atual == 4:
                self._passo5_solucao_minima()
                self.next_button.config(state=tk.DISABLED)
            else:
                self.log_passo("\n[FIM DO CÁLCULO. Clique em 'Reiniciar' para um novo sistema.]")
                self.next_button.config(state=tk.DISABLED)

        except ValueError as e:
            self.log_passo(f"\nERRO FATAL: {e}", 'erro')
            self.output_text.tag_config('erro', foreground='red', font=('Courier', 10, 'bold'))
            messagebox.showerror("Erro de Cálculo", str(e))
            self.next_button.config(state=tk.DISABLED)
        except Exception as e:
            self.log_passo(f"\nERRO INESPERADO: {e}", 'erro')
            messagebox.showerror("Erro", "Ocorreu um erro inesperado.")
            self.next_button.config(state=tk.DISABLED)


    def _passo1_modulo_total(self):
        """ PASSO 1: Calcula N = n1 * n2 * ... """
        self.N = prod(self.n_list)
        self.log_passo_titulo("PASSO 1: Cálculo do Módulo Total (N)")
        self.log_passo(f"N = {' * '.join(map(str, self.n_list))} = {self.N}")
        self.passo_atual = 2

    def _passo2_3_fatores_inversos(self):
        """ PASSO 2 & 3: Calcula M_i e y_i sequencialmente. """
        

        i = self.termo_index
        n_i = self.n_list[i]
        a_i = self.a_list[i]
        
        if i == 0: 
            self.log_passo_titulo("PASSO 2 & 3: Fatores M_i e Inversos y_i (Termo a Termo)")
        
        M_i = self.N // n_i
        y_i = inverso_multiplicativo(M_i, n_i)
        
        self.M.append(M_i)
        self.y.append(y_i)
        
        self.log_passo(f"\n--> Termo {i+1}: a={a_i}, n={n_i}")
        self.log_passo(f"  M_{i+1} = N / n_{i+1} = {self.N} / {n_i} = {M_i}")
        self.log_passo(f"  Inverso: {M_i} * y ≡ 1 (mod {n_i}) -> y_{i+1} = {y_i}")
        
        self.termo_index += 1
        
        if self.termo_index == self.k:
            self.passo_atual = 3 
            self.termo_index = 0 

    def _passo4_construcao_da_solucao(self):
        """ PASSO 4: Constrói a solução X = Σ a_i M_i y_i """
        
        if self.termo_index == 0: 
            self.log_passo_titulo("PASSO 4: Construção da Solução Geral (x = Σ a_i M_i y_i)")
            self.log_passo("Componentes calculados:")
            self.log_passo("  a: " + str(self.a_list))
            self.log_passo("  M: " + str(self.M))
            self.log_passo("  y: " + str(self.y))
            self.log_passo("\nCalculando soma dos termos (a_i * M_i * y_i)...")
        
        i = self.termo_index
        termo = self.a_list[i] * self.M[i] * self.y[i]
        self.x_solucao += termo
        
        self.log_passo(f"  Termo {i+1}: ({self.a_list[i]} * {self.M[i]} * {self.y[i]}) = {termo}")
        self.log_passo(f"  Soma Parcial: {self.x_solucao}")
        
        self.termo_index += 1
        
        if self.termo_index == self.k:
            self.log_passo("\nCálculo finalizado.", 'titulo')
            self.log_passo(f"Solução Geral x: {self.x_solucao}", 'titulo')
            self.passo_atual = 4

    def _passo5_solucao_minima(self):
        """ PASSO 5: Solução Mínima (x mod N) """
        x_minima = self.x_solucao % self.N
        self.log_passo_titulo("PASSO 5: Solução Mínima Positiva")
        self.log_passo(f"x ≡ {self.x_solucao} (mod {self.N})")
        self.log_passo(f"Solução Mínima: x = {x_minima}", 'titulo')
        self.passo_atual = 5 

if __name__ == "__main__":
    root = tk.Tk()
    app = AppTCR(root)
    root.mainloop()
